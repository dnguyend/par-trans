<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>par_trans.utils.expm_multiply_np &mdash; par-trans  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            par-trans
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Numpy Parallel transport</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../par_trans.html">par_trans.manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../par_trans.html#module-par_trans.utils">par_trans.expv</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">JAX Parallel transport</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../jax_par_trans.html">jax_par_trans.manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../jax_par_trans.html#module-jax_par_trans.expv">jax_par_trans.expv</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Resources:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://en.wikipedia.org/wiki/Parallel_transport">Wikipedia</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/dnguyend/par-trans">GitHub</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">par-trans</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">par_trans.utils.expm_multiply_np</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for par_trans.utils.expm_multiply_np</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Compute the action of the matrix exponential. This module is taken</span>
<span class="sd">from scipy, the one difference is we add the option use_frag_31 to see if the</span>
<span class="sd">more difficult algorithm requiring the estimation of a higher norm makes much</span>
<span class="sd">of a difference. This more difficult estimate is one of the reasons the algorithm</span>
<span class="sd">is still not adapted for JAX. We use this module to show it is sufficient to use only the 1-norm in our case.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">la</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="kn">from</span> <span class="nn">scipy.linalg._decomp_qr</span> <span class="kn">import</span> <span class="n">qr</span>
<span class="kn">from</span> <span class="nn">scipy.sparse._sputils</span> <span class="kn">import</span> <span class="n">is_pydata_spmatrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">aslinearoperator</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg._interface</span> <span class="kn">import</span> <span class="n">IdentityOperator</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg._onenormest</span> <span class="kn">import</span> <span class="n">onenormest</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;expm_multiply&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">traceest</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m3</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate `np.trace(A)` using `3*m3` matrix-vector products.</span>

<span class="sd">    The result is not deterministic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : LinearOperator</span>
<span class="sd">        Linear operator whose trace will be estimated. Has to be square.</span>
<span class="sd">    m3 : int</span>
<span class="sd">        Number of matrix-vector products divided by 3 used to estimate the</span>
<span class="sd">        trace.</span>
<span class="sd">    seed : optional</span>
<span class="sd">        Seed for `numpy.random.default_rng`.</span>
<span class="sd">        Can be provided to obtain deterministic results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trace : LinearOperator.dtype</span>
<span class="sd">        Estimate of the trace</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is the Hutch++ algorithm given in [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Meyer, Raphael A., Cameron Musco, Christopher Musco, and David P.</span>
<span class="sd">       Woodruff. &quot;Hutch++: Optimal Stochastic Trace Estimation.&quot; In Symposium</span>
<span class="sd">       on Simplicity in Algorithms (SOSA), pp. 142-155. Society for Industrial</span>
<span class="sd">       and Applied Mathematics, 2021</span>
<span class="sd">       https://doi.org/10.1137/1.9781611976496.16</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected A to be like a square matrix.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m3</span><span class="p">])</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">matmat</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
    <span class="n">trQAQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">matmat</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m3</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">G</span> <span class="o">-</span> <span class="n">Q</span><span class="o">@</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">G</span><span class="p">)</span>
    <span class="n">trGAG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">matmat</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">trQAQ</span> <span class="o">+</span> <span class="n">trGAG</span><span class="o">/</span><span class="n">m3</span>


<span class="k">def</span> <span class="nf">_ident_like</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="c1"># A compatibility function which should eventually disappear.</span>
    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c1"># Creates a sparse matrix in dia format</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dia_array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_pydata_spmatrix</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">sparse</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<div class="viewcode-block" id="expm_multiply">
<a class="viewcode-back" href="../../../par_trans.html#par_trans.utils.expm_multiply_np.expm_multiply">[docs]</a>
<span class="k">def</span> <span class="nf">expm_multiply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">traceA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_frag_31</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the action of the matrix exponential of A on B, using the algorithm described in [1]_ and [2]_ .</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : transposable linear operator</span>
<span class="sd">        The operator whose exponential is of interest.</span>
<span class="sd">    B : ndarray</span>
<span class="sd">        The matrix or vector to be multiplied by the matrix exponential of A.</span>
<span class="sd">    start : scalar, optional</span>
<span class="sd">        The starting time point of the sequence.</span>
<span class="sd">    stop : scalar, optional</span>
<span class="sd">        The end time point of the sequence, unless `endpoint` is set to False.</span>
<span class="sd">        In that case, the sequence consists of all but the last of ``num + 1``</span>
<span class="sd">        evenly spaced time points, so that `stop` is excluded.</span>
<span class="sd">        Note that the step size changes when `endpoint` is False.</span>
<span class="sd">    num : int, optional</span>
<span class="sd">        Number of time points to use.</span>
<span class="sd">    endpoint : bool, optional</span>
<span class="sd">        If True, `stop` is the last time point.  Otherwise, it is not included.</span>
<span class="sd">    traceA : scalar, optional</span>
<span class="sd">        Trace of `A`. If not given the trace is estimated for linear operators,</span>
<span class="sd">        or calculated exactly for sparse matrices. It is used to precondition</span>
<span class="sd">        `A`, thus an approximate trace is acceptable.</span>
<span class="sd">        For linear operators, `traceA` should be provided to ensure performance</span>
<span class="sd">        as the estimation is not guaranteed to be reliable for all cases.</span>
<span class="sd">    use_frag_31 : bool, optional</span>
<span class="sd">         Indicates if we use high_p or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    expm_A_B : ndarray</span>
<span class="sd">         The result of the action :math:`e^{t_k A} B`.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If `A` is a linear operator and ``traceA=None`` (default).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The optional arguments defining the sequence of evenly spaced time points</span>
<span class="sd">    are compatible with the arguments of `numpy.linspace`.</span>

<span class="sd">    The output ndarray shape is somewhat complicated so I explain it here.</span>
<span class="sd">    The ndim of the output could be either 1, 2, or 3.</span>
<span class="sd">    It would be 1 if you are computing the expm action on a single vector</span>
<span class="sd">    at a single time point.</span>
<span class="sd">    It would be 2 if you are computing the expm action on a vector</span>
<span class="sd">    at multiple time points, or if you are computing the expm action</span>
<span class="sd">    on a matrix at a single time point.</span>
<span class="sd">    It would be 3 if you want the action on a matrix with multiple</span>
<span class="sd">    columns at multiple time points.</span>
<span class="sd">    If multiple time points are requested, expm_A_B[0] will always</span>
<span class="sd">    be the action of the expm at the first time point,</span>
<span class="sd">    regardless of whether the action is on a vector or a matrix.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2011)</span>
<span class="sd">           &quot;Computing the Action of the Matrix Exponential,</span>
<span class="sd">           with an Application to Exponential Integrators.&quot;</span>
<span class="sd">           SIAM Journal on Scientific Computing,</span>
<span class="sd">           33 (2). pp. 488-511. ISSN 1064-8275</span>
<span class="sd">           http://eprints.ma.man.ac.uk/1591/</span>

<span class="sd">    .. [2] Nicholas J. Higham and Awad H. Al-Mohy (2010)</span>
<span class="sd">           &quot;Computing Matrix Functions.&quot;</span>
<span class="sd">           Acta Numerica,</span>
<span class="sd">           19. 159-208. ISSN 0962-4929</span>
<span class="sd">           http://eprints.ma.man.ac.uk/1451/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse import csc_matrix</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse.linalg import expm, expm_multiply</span>
<span class="sd">    &gt;&gt;&gt; A = csc_matrix([[1, 0], [0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; A.toarray()</span>
<span class="sd">    array([[1, 0],</span>
<span class="sd">           [0, 1]], dtype=int64)</span>
<span class="sd">    &gt;&gt;&gt; B = np.array([np.exp(-1.), np.exp(-2.)])</span>
<span class="sd">    &gt;&gt;&gt; B</span>
<span class="sd">    array([ 0.36787944,  0.13533528])</span>
<span class="sd">    &gt;&gt;&gt; expm_multiply(A, B, start=1, stop=2, num=3, endpoint=True)</span>
<span class="sd">    array([[ 1.        ,  0.36787944],</span>
<span class="sd">           [ 1.64872127,  0.60653066],</span>
<span class="sd">           [ 2.71828183,  1.        ]])</span>
<span class="sd">    &gt;&gt;&gt; expm(A).dot(B)                  # Verify 1st timestep</span>
<span class="sd">    array([ 1.        ,  0.36787944])</span>
<span class="sd">    &gt;&gt;&gt; expm(1.5*A).dot(B)              # Verify 2nd timestep</span>
<span class="sd">    array([ 1.64872127,  0.60653066])</span>
<span class="sd">    &gt;&gt;&gt; expm(2*A).dot(B)                # Verify 3rd timestep</span>
<span class="sd">    array([ 2.71828183,  1.        ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">)):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_expm_multiply_simple</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">traceA</span><span class="o">=</span><span class="n">traceA</span><span class="p">,</span> <span class="n">use_frag_31</span><span class="o">=</span><span class="n">use_frag_31</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">_expm_multiply_interval</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
                                            <span class="n">endpoint</span><span class="p">,</span> <span class="n">traceA</span><span class="o">=</span><span class="n">traceA</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span></div>



<span class="k">def</span> <span class="nf">_expm_multiply_simple</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">traceA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">balance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_frag_31</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the action of the matrix exponential at a single time point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : transposable linear operator</span>
<span class="sd">        The operator whose exponential is of interest.</span>
<span class="sd">    B : ndarray</span>
<span class="sd">        The matrix to be multiplied by the matrix exponential of A.</span>
<span class="sd">    t : float</span>
<span class="sd">        A time point.</span>
<span class="sd">    traceA : scalar, optional</span>
<span class="sd">        Trace of `A`. If not given the trace is estimated for linear operators,</span>
<span class="sd">        or calculated exactly for sparse matrices. It is used to precondition</span>
<span class="sd">        `A`, thus an approximate trace is acceptable</span>
<span class="sd">    balance : bool</span>
<span class="sd">        Indicates whether or not to apply balancing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        :math:`e^{t A} B`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is algorithm (3.2) in Al-Mohy and Higham (2011).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">balance</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected A to be like a square matrix&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shapes of matrices A </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and B </span><span class="si">{</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; are incompatible&#39;</span><span class="p">)</span>
    <span class="n">ident</span> <span class="o">=</span> <span class="n">_ident_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">is_linear_operator</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected B to be like a matrix or a vector&#39;</span><span class="p">)</span>
    <span class="n">u_d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**-</span><span class="mi">53</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">u_d</span>
    <span class="k">if</span> <span class="n">traceA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_linear_operator</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Trace of LinearOperator not available, it will be estimated.&quot;</span>
                 <span class="s2">&quot; Provide `traceA` to ensure performance.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># m3=1 is bit arbitrary choice, a more accurate trace (larger m3) might</span>
        <span class="c1"># speed up exponential calculation, but trace estimation is more costly</span>
        <span class="n">traceA</span> <span class="o">=</span> <span class="n">traceest</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m3</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_linear_operator</span> <span class="k">else</span> <span class="n">A</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">traceA</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">ident</span>
    <span class="n">A_1_norm</span> <span class="o">=</span> <span class="n">onenormest</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_linear_operator</span> <span class="k">else</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span><span class="o">*</span><span class="n">A_1_norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">norm_info</span> <span class="o">=</span> <span class="n">LazyOperatorNormInfo</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">A_1_norm</span><span class="o">=</span><span class="n">t</span><span class="o">*</span><span class="n">A_1_norm</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">)</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_fragment_3_1</span><span class="p">(</span><span class="n">norm_info</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">,</span> <span class="n">use_frag_31</span><span class="o">=</span><span class="n">use_frag_31</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_expm_multiply_simple_core</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_expm_multiply_simple_core</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">balance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">balance</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u_d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="o">-</span><span class="mi">53</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">u_d</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">B</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">mu</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m_star</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">F</span> <span class="o">+</span> <span class="n">B</span>
            <span class="k">if</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">F</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">F</span>
    <span class="k">return</span> <span class="n">F</span>


<span class="c1"># This table helps to compute bounds.</span>
<span class="c1"># They seem to have been difficult to calculate, involving symbolic</span>
<span class="c1"># manipulation of equations, followed by numerical root finding.</span>
<span class="n">_theta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># The first 30 values are from table A.3 of Computing Matrix Functions.</span>
        <span class="mi">1</span><span class="p">:</span> <span class="mf">2.29e-16</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="mf">2.58e-8</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">:</span> <span class="mf">1.39e-5</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">:</span> <span class="mf">3.40e-4</span><span class="p">,</span>
        <span class="mi">5</span><span class="p">:</span> <span class="mf">2.40e-3</span><span class="p">,</span>
        <span class="mi">6</span><span class="p">:</span> <span class="mf">9.07e-3</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">:</span> <span class="mf">2.38e-2</span><span class="p">,</span>
        <span class="mi">8</span><span class="p">:</span> <span class="mf">5.00e-2</span><span class="p">,</span>
        <span class="mi">9</span><span class="p">:</span> <span class="mf">8.96e-2</span><span class="p">,</span>
        <span class="mi">10</span><span class="p">:</span> <span class="mf">1.44e-1</span><span class="p">,</span>
        <span class="c1"># 11</span>
        <span class="mi">11</span><span class="p">:</span> <span class="mf">2.14e-1</span><span class="p">,</span>
        <span class="mi">12</span><span class="p">:</span> <span class="mf">3.00e-1</span><span class="p">,</span>
        <span class="mi">13</span><span class="p">:</span> <span class="mf">4.00e-1</span><span class="p">,</span>
        <span class="mi">14</span><span class="p">:</span> <span class="mf">5.14e-1</span><span class="p">,</span>
        <span class="mi">15</span><span class="p">:</span> <span class="mf">6.41e-1</span><span class="p">,</span>
        <span class="mi">16</span><span class="p">:</span> <span class="mf">7.81e-1</span><span class="p">,</span>
        <span class="mi">17</span><span class="p">:</span> <span class="mf">9.31e-1</span><span class="p">,</span>
        <span class="mi">18</span><span class="p">:</span> <span class="mf">1.09</span><span class="p">,</span>
        <span class="mi">19</span><span class="p">:</span> <span class="mf">1.26</span><span class="p">,</span>
        <span class="mi">20</span><span class="p">:</span> <span class="mf">1.44</span><span class="p">,</span>
        <span class="c1"># 21</span>
        <span class="mi">21</span><span class="p">:</span> <span class="mf">1.62</span><span class="p">,</span>
        <span class="mi">22</span><span class="p">:</span> <span class="mf">1.82</span><span class="p">,</span>
        <span class="mi">23</span><span class="p">:</span> <span class="mf">2.01</span><span class="p">,</span>
        <span class="mi">24</span><span class="p">:</span> <span class="mf">2.22</span><span class="p">,</span>
        <span class="mi">25</span><span class="p">:</span> <span class="mf">2.43</span><span class="p">,</span>
        <span class="mi">26</span><span class="p">:</span> <span class="mf">2.64</span><span class="p">,</span>
        <span class="mi">27</span><span class="p">:</span> <span class="mf">2.86</span><span class="p">,</span>
        <span class="mi">28</span><span class="p">:</span> <span class="mf">3.08</span><span class="p">,</span>
        <span class="mi">29</span><span class="p">:</span> <span class="mf">3.31</span><span class="p">,</span>
        <span class="mi">30</span><span class="p">:</span> <span class="mf">3.54</span><span class="p">,</span>
        <span class="c1"># The rest are from table 3.1 of</span>
        <span class="c1"># Computing the Action of the Matrix Exponential.</span>
        <span class="mi">35</span><span class="p">:</span> <span class="mf">4.7</span><span class="p">,</span>
        <span class="mi">40</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">,</span>
        <span class="mi">45</span><span class="p">:</span> <span class="mf">7.2</span><span class="p">,</span>
        <span class="mi">50</span><span class="p">:</span> <span class="mf">8.5</span><span class="p">,</span>
        <span class="mi">55</span><span class="p">:</span> <span class="mf">9.9</span><span class="p">,</span>
        <span class="p">}</span>


<span class="k">def</span> <span class="nf">_onenormest_matrix_power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
        <span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">itmax</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">compute_v</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_w</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Efficiently estimate the 1-norm of A^p.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : ndarray</span>
<span class="sd">        Matrix whose 1-norm of a power is to be computed.</span>
<span class="sd">    p : int</span>
<span class="sd">        Non-negative integer power.</span>
<span class="sd">    t : int, optional</span>
<span class="sd">        A positive parameter controlling the tradeoff between</span>
<span class="sd">        accuracy versus time and memory usage.</span>
<span class="sd">        Larger values take longer and use more memory</span>
<span class="sd">        but give more accurate output.</span>
<span class="sd">    itmax : int, optional</span>
<span class="sd">        Use at most this many iterations.</span>
<span class="sd">    compute_v : bool, optional</span>
<span class="sd">        Request a norm-maximizing linear operator input vector if True.</span>
<span class="sd">    compute_w : bool, optional</span>
<span class="sd">        Request a norm-maximizing linear operator output vector if True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    est : float</span>
<span class="sd">        An underestimate of the 1-norm of the sparse matrix.</span>
<span class="sd">    v : ndarray, optional</span>
<span class="sd">        The vector such that ||Av||_1 == est*||v||_1.</span>
<span class="sd">        It can be thought of as an input to the linear operator</span>
<span class="sd">        that gives an output with particularly large norm.</span>
<span class="sd">    w : ndarray, optional</span>
<span class="sd">        The vector Av which has relatively large 1-norm.</span>
<span class="sd">        It can be thought of as an output of the linear operator</span>
<span class="sd">        that is relatively large in norm compared to the input.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#XXX Eventually turn this into an API function in the  _onenormest module,</span>
    <span class="c1">#XXX and remove its underscore,</span>
    <span class="c1">#XXX but wait until expm_multiply goes into scipy.</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg._onenormest</span> <span class="kn">import</span> <span class="n">onenormest</span>
    <span class="k">return</span> <span class="n">onenormest</span><span class="p">(</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LazyOperatorNormInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Information about an operator is lazily computed.</span>

<span class="sd">    The information includes the exact 1-norm of the operator,</span>
<span class="sd">    in addition to estimates of 1-norms of powers of the operator.</span>
<span class="sd">    This uses the notation of Computing the Action (2011).</span>
<span class="sd">    This class is specialized enough to probably not be of general interest</span>
<span class="sd">    outside of this module.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">A_1_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide the operator and some norm-related information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : linear operator</span>
<span class="sd">            The operator of interest.</span>
<span class="sd">        A_1_norm : float, optional</span>
<span class="sd">            The exact 1-norm of A.</span>
<span class="sd">        ell : int, optional</span>
<span class="sd">            A technical parameter controlling norm estimation quality.</span>
<span class="sd">        scale : int, optional</span>
<span class="sd">            If specified, return the norms of scale*A instead of A.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A_1_norm</span> <span class="o">=</span> <span class="n">A_1_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ell</span> <span class="o">=</span> <span class="n">ell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the scale parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">onenorm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the exact 1-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_1_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A_1_norm</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_A_1_norm</span>

    <span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lazily estimate :math:`d_p(A) ~= || A^p ||^(1/p)` </span>
<span class="sd">        where :math:`||.||` is the 1-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">:</span>
            <span class="n">est</span> <span class="o">=</span> <span class="n">_onenormest_matrix_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ell</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">est</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lazily compute max(d(p), d(p+1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_compute_cost_div_m</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">norm_info</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function for computing bounds.</span>

<span class="sd">    This is equation (3.10).</span>
<span class="sd">    It measures cost in terms of the number of required matrix products.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        A valid key of _theta.</span>
<span class="sd">    p : int</span>
<span class="sd">        A matrix power.</span>
<span class="sd">    norm_info : LazyOperatorNormInfo</span>
<span class="sd">        Information about 1-norms of related operators.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cost_div_m : int</span>
<span class="sd">        Required number of matrix products divided by m.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">norm_info</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">_theta</span><span class="p">[</span><span class="n">m</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">_compute_p_max</span><span class="p">(</span><span class="n">m_max</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the largest positive integer p such that p*(p-1) &lt;= m_max + 1.</span>

<span class="sd">    Do this in a slightly dumb way, but safe and not too slow.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m_max : int</span>
<span class="sd">        A count related to bounds.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sqrt_m_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m_max</span><span class="p">)</span>
    <span class="n">p_low</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">sqrt_m_max</span><span class="p">))</span>
    <span class="n">p_high</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sqrt_m_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_low</span><span class="p">,</span> <span class="n">p_high</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">m_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fragment_3_1</span><span class="p">(</span><span class="n">norm_info</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">m_max</span><span class="o">=</span><span class="mi">55</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">use_frag_31</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function for the _expm_multiply_* functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    norm_info : LazyOperatorNormInfo</span>
<span class="sd">        Information about norms of certain linear operators of interest.</span>
<span class="sd">    n0 : int</span>
<span class="sd">        Number of columns in the _expm_multiply_* B matrix.</span>
<span class="sd">    tol : float</span>
<span class="sd">        Expected to be</span>
<span class="sd">        :math:`2^{-24}` for single precision or</span>
<span class="sd">        :math:`2^{-53}` for double precision.</span>
<span class="sd">    m_max : int</span>
<span class="sd">        A value related to a bound.</span>
<span class="sd">    ell : int</span>
<span class="sd">        The number of columns used in the 1-norm approximation.</span>
<span class="sd">        This is usually taken to be small, maybe between 1 and 5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    best_m : int</span>
<span class="sd">        Related to bounds for error control.</span>
<span class="sd">    best_s : int</span>
<span class="sd">        Amount of scaling.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is code fragment (3.1) in Al-Mohy and Higham (2011).</span>
<span class="sd">    The discussion of default values for m_max and ell</span>
<span class="sd">    is given between the definitions of equation (3.11)</span>
<span class="sd">    and the definition of equation (3.12).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ell</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected ell to be a positive integer&#39;</span><span class="p">)</span>
    <span class="n">best_m</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">best_s</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_frag_31</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_condition_3_13</span><span class="p">(</span><span class="n">norm_info</span><span class="o">.</span><span class="n">onenorm</span><span class="p">(),</span> <span class="n">n0</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">ell</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">_theta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">norm_info</span><span class="o">.</span><span class="n">onenorm</span><span class="p">()</span> <span class="o">/</span> <span class="n">theta</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">best_m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">best_m</span> <span class="o">*</span> <span class="n">best_s</span><span class="p">:</span>
                <span class="n">best_m</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">best_s</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Equation (3.11).</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">_compute_p_max</span><span class="p">(</span><span class="n">m_max</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">_theta</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">_compute_cost_div_m</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">norm_info</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">best_m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">best_m</span> <span class="o">*</span> <span class="n">best_s</span><span class="p">:</span>
                        <span class="n">best_m</span> <span class="o">=</span> <span class="n">m</span>
                        <span class="n">best_s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">best_s</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best_s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best_m</span><span class="p">,</span> <span class="n">best_s</span>


<span class="k">def</span> <span class="nf">_condition_3_13</span><span class="p">(</span><span class="n">A_1_norm</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">ell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function for the _expm_multiply_* functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A_1_norm : float</span>
<span class="sd">        The precomputed 1-norm of A.</span>
<span class="sd">    n0 : int</span>
<span class="sd">        Number of columns in the _expm_multiply_* B matrix.</span>
<span class="sd">    m_max : int</span>
<span class="sd">        A value related to a bound.</span>
<span class="sd">    ell : int</span>
<span class="sd">        The number of columns used in the 1-norm approximation.</span>
<span class="sd">        This is usually taken to be small, maybe between 1 and 5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    value : bool</span>
<span class="sd">        Indicates whether or not the condition has been met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is condition (3.13) in Al-Mohy and Higham (2011).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This is the rhs of equation (3.12).</span>
    <span class="n">p_max</span> <span class="o">=</span> <span class="n">_compute_p_max</span><span class="p">(</span><span class="n">m_max</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ell</span> <span class="o">*</span> <span class="n">p_max</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_max</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Evaluate the condition (3.13).</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_theta</span><span class="p">[</span><span class="n">m_max</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n0</span> <span class="o">*</span> <span class="n">m_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_1_norm</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_expm_multiply_interval</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">traceA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">balance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">status_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the action of the matrix exponential at multiple time points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : transposable linear operator</span>
<span class="sd">        The operator whose exponential is of interest.</span>
<span class="sd">    B : ndarray</span>
<span class="sd">        The matrix to be multiplied by the matrix exponential of A.</span>
<span class="sd">    start : scalar, optional</span>
<span class="sd">        The starting time point of the sequence.</span>
<span class="sd">    stop : scalar, optional</span>
<span class="sd">        The end time point of the sequence, unless `endpoint` is set to False.</span>
<span class="sd">        In that case, the sequence consists of all but the last of ``num + 1``</span>
<span class="sd">        evenly spaced time points, so that `stop` is excluded.</span>
<span class="sd">        Note that the step size changes when `endpoint` is False.</span>
<span class="sd">    num : int, optional</span>
<span class="sd">        Number of time points to use.</span>
<span class="sd">    traceA : scalar, optional</span>
<span class="sd">        Trace of `A`. If not given the trace is estimated for linear operators,</span>
<span class="sd">        or calculated exactly for sparse matrices. It is used to precondition</span>
<span class="sd">        `A`, thus an approximate trace is acceptable</span>
<span class="sd">    endpoint : bool, optional</span>
<span class="sd">        If True, `stop` is the last time point. Otherwise, it is not included.</span>
<span class="sd">    balance : bool</span>
<span class="sd">        Indicates whether or not to apply balancing.</span>
<span class="sd">    status_only : bool</span>
<span class="sd">        A flag that is set to True for some debugging and testing operations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        :math:`e^{t_k A} B`</span>
<span class="sd">    status : int</span>
<span class="sd">        An integer status for testing and debugging.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is algorithm (5.2) in Al-Mohy and Higham (2011).</span>

<span class="sd">    There seems to be a typo, where line 15 of the algorithm should be</span>
<span class="sd">    moved to line 6.5 (between lines 6 and 7).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">balance</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected A to be like a square matrix&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shapes of matrices A </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and B </span><span class="si">{</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; are incompatible&#39;</span><span class="p">)</span>
    <span class="n">ident</span> <span class="o">=</span> <span class="n">_ident_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">is_linear_operator</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected B to be like a matrix or a vector&#39;</span><span class="p">)</span>
    <span class="n">u_d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**-</span><span class="mi">53</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">u_d</span>
    <span class="k">if</span> <span class="n">traceA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_linear_operator</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Trace of LinearOperator not available, it will be estimated.&quot;</span>
                 <span class="s2">&quot; Provide `traceA` to ensure performance.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># m3=5 is bit arbitrary choice, a more accurate trace (larger m3) might</span>
        <span class="c1"># speed up exponential calculation, but trace estimation is also costly</span>
        <span class="c1"># an educated guess would need to consider the number of time points</span>
        <span class="n">traceA</span> <span class="o">=</span> <span class="n">traceest</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m3</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_linear_operator</span> <span class="k">else</span> <span class="n">A</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">traceA</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Get the linspace samples, attempting to preserve the linspace defaults.</span>
    <span class="n">linspace_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;retstep&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">linspace_kwargs</span><span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">linspace_kwargs</span><span class="p">[</span><span class="s1">&#39;endpoint&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoint</span>
    <span class="n">samples</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="o">**</span><span class="n">linspace_kwargs</span><span class="p">)</span>

    <span class="c1"># Convert the linspace output to the notation used by the publication.</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsamples</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;at least two time points are required&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">step</span>
    <span class="n">t_0</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t_q</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>

    <span class="c1"># Define the output ndarray.</span>
    <span class="c1"># Use an ndim=3 shape, such that the last two indices</span>
    <span class="c1"># are the ones that may be involved in level 3 BLAS operations.</span>
    <span class="n">X_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsamples</span><span class="p">,)</span> <span class="o">+</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_q</span> <span class="o">-</span> <span class="n">t_0</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">ident</span>
    <span class="n">A_1_norm</span> <span class="o">=</span> <span class="n">onenormest</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_linear_operator</span> <span class="k">else</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ell</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">norm_info</span> <span class="o">=</span> <span class="n">LazyOperatorNormInfo</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">A_1_norm</span><span class="o">=</span><span class="n">t</span><span class="o">*</span><span class="n">A_1_norm</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span><span class="o">*</span><span class="n">A_1_norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_fragment_3_1</span><span class="p">(</span><span class="n">norm_info</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">)</span>

    <span class="c1"># Compute the expm action up to the initial time point.</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_expm_multiply_simple_core</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">t_0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Compute the expm action at the rest of the time points.</span>
    <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">status_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_expm_multiply_interval_core_0</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">norm_info</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ell</span><span class="p">,</span><span class="n">n0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">q</span> <span class="o">%</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_expm_multiply_interval_core_1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">q</span> <span class="o">%</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_expm_multiply_interval_core_2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;internal error&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_expm_multiply_interval_core_0</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">norm_info</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ell</span><span class="p">,</span> <span class="n">n0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function, for the case q &lt;= s.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute the new values of m_star and s which should be applied</span>
    <span class="c1"># over intervals of size t/q</span>
    <span class="k">if</span> <span class="n">norm_info</span><span class="o">.</span><span class="n">onenorm</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">norm_info</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">q</span><span class="p">)</span>
        <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">_fragment_3_1</span><span class="p">(</span><span class="n">norm_info</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="n">ell</span><span class="p">)</span>
        <span class="n">norm_info</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_expm_multiply_simple_core</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_expm_multiply_interval_core_1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function, for the case q &gt; s and q % s == 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">q</span> <span class="o">//</span> <span class="n">s</span>
    <span class="n">input_shape</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">K_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_star</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">input_shape</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">K_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">]</span>
        <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="n">high_p</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_star</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">high_p</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
                <span class="n">F</span> <span class="o">=</span> <span class="n">F</span> <span class="o">+</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="n">inf_norm_K_p_1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">inf_norm_K_p_1</span>
                <span class="k">if</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span>
            <span class="n">X</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">F</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_expm_multiply_interval_core_2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">m_star</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function, for the case q &gt; s and q % s &gt; 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">q</span> <span class="o">//</span> <span class="n">s</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">q</span> <span class="o">//</span> <span class="n">d</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">d</span> <span class="o">*</span> <span class="n">j</span>
    <span class="n">input_shape</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">K_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_star</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">input_shape</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">K_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">]</span>
        <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="n">high_p</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">effective_d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">effective_d</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">effective_d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_star</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">high_p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">high_p</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
                <span class="n">F</span> <span class="o">=</span> <span class="n">F</span> <span class="o">+</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="n">inf_norm_K_p_1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">inf_norm_K_p_1</span>
                <span class="k">if</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span>
            <span class="n">X</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">F</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Du Nguyen and Stefan Sommer.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>